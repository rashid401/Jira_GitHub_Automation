```markdown
# ğŸ¤– GitHub-Jira Automation Shield

[![Python Version](https://img.shields.io/badge/python-3.14-blue.svg)](https://www.python.org/)
[![Redis Version](https://img.shields.io/badge/redis-8.4-red.svg)](https://redis.io/)
[![Docker](https://img.shields.io/badge/docker-compose-blue.svg)](https://www.docker.com/)

A high-performance, containerized middleware that transforms GitHub issue comments into Jira tickets. Built with a **Redis Deduplication Shield** to prevent race conditions and duplicate ticket creation from GitHub's retry logic.

---

## ğŸ—ï¸ Architecture Overview

The system operates as a microservice stack managed by Docker Compose:

1.  **Flask Bot (Python 3.14-alpine):** The core logic engine. It validates GitHub signatures, parses payloads, and interfaces with the Jira REST API.
2.  **Redis Cache (8.4.0-alpine):** The "Short-term Memory." It stores unique `X-GitHub-Delivery` IDs for 24 hours to ensure every webhook is processed exactly once.
3.  **Persistence Layer:** Logs are mounted to the host machine for real-time monitoring and historical auditing.



---

## ğŸ› ï¸ Tech Stack & Features

* **Python 3.14 (Alpine):** Leveraging the latest performance improvements and minimal image size.
* **Redis 8.4:** High-speed deduplication with automatic 24-hour TTL (Time-To-Live).
* **Gunicorn:** Production-grade WSGI server for handling concurrent requests.
* **Deduplication Shield:** Instant rejection of duplicate GitHub delivery attempts.
* **Robust Logging:** Integrated `RotatingFileHandler` to prevent disk exhaustion.

### ğŸ”„ Bidirectional Sync
- **Jira Creation:** Automatically generates tickets based on GitHub comment triggers.
- **GitHub Feedback:** Once a ticket is created, the bot automatically comments on the GitHub issue with a direct link to the Jira ticket, ensuring the development team stays informed without leaving GitHub.

---

## ğŸš¦ Getting Started

### 1. Project Structure
```text
.
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ fully_automated_jira_github.py  # Application Entry Point
â”‚   â”œâ”€â”€ config.py                       # Configuration Management
â”‚   â””â”€â”€ requirements.txt                # Dependency Manifest
â”œâ”€â”€ logs/                               # Persistent Log Files
â”œâ”€â”€ .env                                # Environment Secrets
â”œâ”€â”€ Dockerfile                          # Bot Image Build Script
â””â”€â”€ docker-compose.yml                  # Service Orchestration

```

### 2. Environment Setup

Create a `.env` file in the root directory and populate it with your credentials:

```bash
# Set to True for local development, False for production
FLASK_DEBUG=False
PORT=8000

# Log file location
LOG_FILE=/app/logs/github_jira_automation.log

# Jira Credentials
JIRA_SERVER=[https://your-domain.atlassian.net](https://your-domain.atlassian.net)
JIRA_USER=your-email@example.com
JIRA_API_TOKEN=your_jira_token
JIRA_PROJECT_KEY=Your_server_key

# GitHub Security
GITHUB_WEBHOOK_SECRET=your_secret_here
GITHUB_TOKEN=ghp_your_token_here

# --- Redis Configuration ---
# REDIS_HOST = redis_service #<define your redis service name (redi-service)> # HOST is directly embedded in docker-compose file
REDIS_PORT = 6379
```

### 3. Deployment

Deploy the entire stack with a single command:

```bash
docker-compose up -d --build

```

---

## ğŸ“Š Operations & Maintenance

### Monitoring Logs

Watch the bot process events in real-time:

```bash
docker logs -f jira-bot

```

### Investigating the Cache

To see how many IDs are currently stored in the Redis shield:

```bash
docker exec -it redis_service redis-cli info keyspace

```

### Manual Cache Reset

If you need to force-reprocess a specific event window:

```bash
docker exec -it redis_service redis-cli flushall

```

---

## ğŸ›¡ï¸ Security Best Practices

* **Signature Verification:** The bot rejects any request that doesn't match the `X-Hub-Signature-256` generated by GitHub.
* **Minimalist Images:** Using `alpine` variants for both Python and Redis to reduce the attack surface.
* **Network Isolation:** Redis is not exposed to the public internet; it is only reachable by the Bot container within the internal Docker bridge network.

---

## ğŸ“ License

This project is licensed under the MIT License - see the LICENSE file for details.

```